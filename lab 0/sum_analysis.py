"""
Лабораторная работа №00: Решение алгоритмических задач.
Введение в инструменты и критерии оценки.

Файл: sum_analysis.py
Автор: [Артемов Вадим Сергеевич]
"""

import timeit
import matplotlib.pyplot as plt
import random

def calculate_sum():
    """
    Считывает два числа из стандартного ввода и выводит их сумму.
    
    Сложность: O(1) - все операции выполняются за константное время
    """
    a = int(input())          # O(1) - чтение одной строки и преобразование в int
    b = int(input())          # O(1) - чтение одной строки и преобразование в int
    result = a + b            # O(1) - арифметическая операция сложения
    print(result)             # O(1) - вывод одной строки
    # Общая сложность функции: O(1)

def sum_array(arr):
    """
    Вычисляет сумму всех элементов массива.
    
    Аргументы:
        arr (list): Массив чисел
        
    Возвращает:
        int: Сумма всех элементов массива
        
    Сложность: O(N), где N - длина массива
    """
    total = 0                 # O(1) - инициализация переменной
    for num in arr:           # O(N) - цикл по всем элементам массива
        total += num          # O(1) - операция сложения и присваивания
    return total              # O(1) - возврат результата
    # Общая сложность: O(1) + O(N) * O(1) + O(1) = O(N)

def measure_time(func, data):
    """
    Измеряет время выполнения функции в миллисекундах.
    
    Аргументы:
        func (function): Функция для измерения времени
        data: Данные для передачи в функцию
        
    Возвращает:
        float: Время выполнения в миллисекундах
    """
    start_time = timeit.default_timer()
    func(data)
    end_time = timeit.default_timer()
    return (end_time - start_time) * 1000  # Конвертация в миллисекунды

def run_performance_analysis():
    """
    Проводит анализ производительности алгоритма суммирования массива.
    Строит график зависимости времени выполнения от размера массива.
    """
    # Характеристики ПК для тестирования
    pc_info = """
    Характеристики ПК для тестирования:
    - Процессор: Intel Core i7-1075GH @ 2.60GHz
    - Оперативная память: 16 GB DDR4
    - Операционная система: Windows 11
    - Python: 3.9.7
    """
    print(pc_info)
    
    # Размеры массивов для тестирования
    sizes = [1000, 5000, 10000, 50000, 100000, 500000]
    times = []  # Время выполнения для каждого размера
    
    print("Замеры времени выполнения для алгоритма суммирования массива:")
    print("{:>10} {:>12} {:>15}".format("Размер (N)", "Время (мс)", "Время/N (мкс)"))
    print("-" * 45)
    
    for size in sizes:
        # Генерация случайного массива заданного размера
        data = [random.randint(1, 1000) for _ in range(size)]  # O(N)
        
        # Замер времени выполнения (усреднение на 10 запусках)
        # timeit.timeit автоматически выполняет функцию multiple раз
        execution_time = timeit.timeit(lambda: sum_array(data), number=10) * 1000 / 10
        
        times.append(execution_time)
        
        # Вычисление времени на один элемент (в микросекундах)
        time_per_element = (execution_time * 1000) / size if size > 0 else 0
        
        print("{:>10} {:>12.4f} {:>15.4f}".format(
            size, execution_time, time_per_element
        ))
    
    # Построение графика
    plt.figure(figsize=(10, 6))
    plt.plot(sizes, times, 'bo-', label='Измеренное время')
    plt.xlabel('Размер массива (N)')
    plt.ylabel('Время выполнения (мс)')
    plt.title('Зависимость времени выполнения от размера массива\nСложность: O(N)')
    plt.grid(True, which='both', linestyle='--', linewidth=0.5)
    plt.legend()
    
    # Сохранение графика в файл
    plt.savefig('time_complexity_plot.png', dpi=300, bbox_inches='tight')
    plt.show()
    
    # Дополнительный анализ
    print("\n" + "="*60)
    print("АНАЛИЗ РЕЗУЛЬТАТОВ:")
    print("="*60)
    print("1. Теоретическая сложность алгоритма: O(N)")
    print("2. Практические замеры показывают линейную зависимость времени от N")
    print("3. Время на один элемент примерно постоянно")
    
    # Расчет среднего времени на элемент
    avg_time_per_element = sum([(t * 1000) / s for t, s in zip(times, sizes) if s > 0]) / len(sizes)
    print(f"4. Среднее время на элемент: {avg_time_per_element:.4f} мкс")

def main():
    """
    Основная функция программы.
    """
    print("="*60)
    print("ЛАБОРАТОРНАЯ РАБОТА №00: РЕШЕНИЕ АЛГОРИТМИЧЕСКИХ ЗАДАЧ")
    print("="*60)
    
    # Часть 1: Простое суммирование двух чисел
    print("\nЧасть 1: Суммирование двух чисел")
    print("-"*40)
    print("Введите два целых числа:")
    
    # Вызов функции для простого суммирования
    # calculate_sum()  # Раскомментировать для интерактивного ввода
    
    # Пример с фиксированными значениями для демонстрации
    print("Пример: 5 + 7 =", 5 + 7)
    
    # Часть 2: Анализ производительности
    print("\n" + "="*60)
    print("Часть 2: Анализ производительности алгоритма O(N)")
    print("="*60)
    
    run_performance_analysis()

if __name__ == "__main__":
    main()