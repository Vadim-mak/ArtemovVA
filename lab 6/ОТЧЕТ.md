# Лабораторная работа №6  
## Бинарные деревья поиска (BST)

---

### **Информация о выполнении**
| **Семестр** | 3 курс, 1 полугодие (5 семестр) |
| **Группа** | ПИЖ-б-о-23-2(2) |
| **Дисциплина** | Анализ сложности алгоритмов |
| **Студент** | Артемов Вадим Сергеевич |
| **Статус работы** | Завершено |
---

### **Цель работы**

Изучить древовидные структуры данных, их свойства и применение. Освоить основные операции с бинарными деревьями поиска (BST), реализовать алгоритмы вставки, поиска, обхода деревьев и провести анализ их производительности.

---

### **Теоретическая часть**

#### **Основные понятия**

**Бинарное дерево поиска (BST)** — это древовидная структура данных, в которой для каждого узла выполняется:

- Все значения в **левом поддереве** меньше значения узла
- Все значения в **правом поддереве** больше значения узла
- Оба поддерева также являются BST

#### **Операции BST**

| Операция | Описание | Сложность (средний случай) | Сложность (худший случай) |
|----------|----------|----------------------------|---------------------------|
| **Вставка** | Добавление нового элемента | O(log n) | O(n) |
| **Поиск** | Проверка наличия элемента | O(log n) | O(n) |
| **Обход** | Посещение всех узлов | O(n) | O(n) |

#### **Виды обходов дерева**

1. **In-order** (левый → корень → правый)
   - Возвращает элементы в отсортированном порядке
   
2. **Pre-order** (корень → левый → правый)
   - Полезен для копирования структуры дерева
   
3. **Post-order** (левый → правый → корень)
   - Полезен для удаления дерева

---

### **Практическая часть**

#### **Выполненные задачи**

- Реализован класс `TreeNode` для представления узла дерева
- Реализован класс `BinarySearchTree` с основными операциями
- Написаны тесты для проверки корректности работы
- Проведен анализ производительности
- Сравнение сбалансированного и вырожденного деревьев

#### **Структура проекта**
lab6/
├── binary_search_tree.py # Реализация BST
├── tree_analysis.py # Анализ производительности
├── main.py # Основная программа
└── README.md # Отчет

Результаты выполнения
Пример работы программы

Лабораторная работа 6: Бинарные деревья поиска
==================================================

1. Вставка значений в дерево:
   Вставлено: 50
   Вставлено: 30
   Вставлено: 20
   Вставлено: 40
   Вставлено: 70
   Вставлено: 60
   Вставлено: 80

2. Поиск значений в дереве:
   Поиск 30: найден
   Поиск 45: не найден
   Поиск 60: найден
   Поиск 100: не найден

3. Обход дерева (in-order):
   Результат: [20, 30, 40, 50, 60, 70, 80]
Ключевой фрагмент кода
python
def insert(self, value: int) -> None:
    """Итеративная вставка значения в дерево"""
    new_node = TreeNode(value)
    
    if self.root is None:
        self.root = new_node
        return
    
    current = self.root
    while True:
        if value < current.value:
            if current.left is None:
                current.left = new_node
                return
            current = current.left
        elif value > current.value:
            if current.right is None:
                current.right = new_node
                return
            current = current.right
        else:
            # Значение уже существует
            return
Результаты теста производительности
Тип дерева	Размер	Время вставки (мс)	Время поиска (мс)
Сбалансированное	15 элементов	0.0156	0.0102
Вырожденное	15 элементов	0.0489	0.0367
Отношение времен:

Вставка (вырожденное/сбалансированное): 3.13×

Поиск (вырожденное/сбалансированное): 3.60×

Анализ результатов
Наблюдения
Сбалансированное дерево демонстрирует логарифмическую сложность операций

Вырожденное дерево показывает линейную сложность операций

Разница в производительности становится значительной при увеличении размера дерева

In-order обход всегда возвращает отсортированную последовательность

Графическая интерпретация
text
Сбалансированное дерево:        Вырожденное дерево:
        50                      1
       /  \                      \
      30   70                    2
     / \   / \                    \
    20 40 60 80                   3
                                   \
                                    ...

Выводы:
Эффективность BST напрямую зависит от его сбалансированности

Сбалансированное дерево обеспечивает O(log n) время операций

Вырожденное дерево превращается в связный список с O(n) временем

In-order обход всегда возвращает элементы в отсортированном порядке

Для практического применения рекомендуется использовать самобалансирующиеся деревья (AVL, красно-черные)

Ответы на контрольные вопросы
1. Сформулируйте основное свойство бинарного дерева поиска (BST).
Для каждого узла дерева все значения в левом поддереве меньше значения узла, а все значения в правом поддереве больше значения узла.

2. Опишите алгоритм вставки нового элемента в BST. Какова сложность этой операции?
Алгоритм начинается с корня дерева. Значение сравнивается с текущим узлом: если меньше — переход к левому потомку, если больше — к правому. Процесс повторяется до нахождения пустой позиции.
Сложность:

В сбалансированном дереве: O(log n)

В вырожденном дереве: O(n)

3. Чем отличается обход дерева в глубину (DFS) от обхода в ширину (BFS)?
DFS идет вглубь дерева по ветвям (использует стек), BFS обходит дерево уровень за уровнем (использует очередь).
Виды DFS-обходов:

In-order (левый-корень-правый) — возвращает отсортированные значения

Pre-order (корень-левый-правый) — полезен для копирования структуры

Post-order (левый-правый-корень) — полезен для удаления дерева

4. Почему в вырожденном BST сложность операций становится O(n)?
Вырожденное дерево (например, при вставке отсортированных значений) превращается в связный список, где высота дерева равна количеству элементов. В этом случае операции требуют последовательного прохода через все элементы.

5. Что такое сбалансированное дерево и как оно решает проблему вырождения BST?
Сбалансированное дерево (например, AVL или красно-черное дерево) автоматически поддерживает высоту O(log n) путем перебалансировки при вставке и удалении элементов. Это гарантирует эффективность операций даже в худшем случае.
