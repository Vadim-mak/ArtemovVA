# Отчет по лабораторной работе №9
## Исследование алгоритмов динамического программирования

**Семестр:** 3 курс, 5 семестр (1 полугодие)  
**Группа:** ПИЖ-б-о-23-2(2)  
**Дисциплина:** Анализ сложности алгоритмов  
**Студент:** Артемов Вадим Сергеевич   

---

## Цель работы

Изучить метод динамического программирования как мощный инструмент для решения сложных задач путем разбиения их на перекрывающиеся подзадачи. Освоить два основных подхода к реализации ДП: нисходящий (с мемоизацией) и восходящий (с заполнением таблицы). Получить практические навыки выявления оптимальной подструктуры задач, построения таблиц ДП и анализа временной и пространственной сложности алгоритмов.

---

## Теоретическая часть

### Основные понятия

**Динамическое программирование (ДП)** — метод решения задач, в которых оптимальное решение всей задачи зависит от оптимальных решений её перекрывающихся подзадач.

### Ключевые принципы:

1. **Оптимальная подструктура** — оптимальное решение задачи может быть построено из оптимальных решений её подзадач.
2. **Перекрывающиеся подзадачи** — подзадачи, решения которых используются многократно, а не один раз.

### Подходы к реализации:

- **Нисходящее ДП (Top-Down, с мемоизацией)** — рекурсивное решение с сохранением (кэшированием) результатов решения подзадач для повторных вычислений.
- **Восходящее ДП (Bottom-Up, табличное)** — итеративное решение, при котором подзадачи решаются от простейших к сложным, а их результаты заносятся в таблицу (массив).

### Изученные классические задачи ДП:

1. **Числа Фибоначчи** — классический пример перекрывающихся подзадач
2. **Задача о рюкзаке 0-1** — выбор предметов с максимальной суммарной стоимостью без дробления
3. **Наибольшая общая подпоследовательность (LCS)** — поиск самой длинной последовательности символов, которая является подпоследовательностью двух строк
4. **Расстояние Левенштейна** — минимальное количество операций вставки, удаления и замены символа для превращения одной строки в другую
5. **Размен монет** — минимальное количество монет для выдачи суммы и количество способов размена
6. **Наибольшая возрастающая подпоследовательность (LIS)**
7. **Перемножение матриц** — оптимальная расстановка скобок при перемножении цепочки матриц

---

## Практическая часть

### Выполненные задачи

#### 1. Реализация алгоритмов

Все алгоритмы динамического программирования реализованы в файле `dynamic_programming.py`:

- 4 метода вычисления чисел Фибоначчи:
  - Наивный рекурсивный (`fibonacci_naive`)
  - С мемоизацией (`fibonacci_memoization`)
  - Табличный (`fibonacci_tabulation`)
  - Оптимизированный (`fibonacci_optimized`)
- 2 метода решения задачи о рюкзаке 0-1:
  - Базовый ДП (`knapsack_01`)
  - С оптимизацией памяти (`knapsack_01_optimized`)
- Наибольшая общая подпоследовательность:
  - Базовый алгоритм (`longest_common_subsequence`)
  - С восстановлением решения (`lcs_with_reconstruction`)
- Задачи на размен монет:
  - Минимальное количество монет (`coin_change_min_coins`)
  - Количество способов размена (`coin_change_ways`)
- Наибольшая возрастающая подпоследовательность (`longest_increasing_subsequence`)
- Расстояние Левенштейна (`edit_distance`)
- Перемножение матриц (`matrix_chain_order`)

#### 2. Демонстрационная программа

В файле `main.py` создана программа, которая наглядно демонстрирует работу всех алгоритмов:

def demonstrate_fibonacci():
    """Демонстрация методов вычисления чисел Фибоначчи"""
    print("1. Числа Фибоначчи")
    print("-" * 40)
    
    n = 10
    print(f"Вычисление F({n}):")
    
    # Наивный метод
    result_naive = fibonacci_naive(n)
    print(f"  Наивный рекурсивный: F({n}) = {result_naive}")
    
    # Мемоизация
    result_memo = fibonacci_memoization(n)
    print(f"  С мемоизацией: F({n}) = {result_memo}")
    
    # Табличный метод
    result_tab = fibonacci_tabulation(n)
    print(f"  Табличный метод: F({n}) = {result_tab}")
    
    # Оптимизированный метод
    result_opt = fibonacci_optimized(n)
    print(f"  Оптимизированный: F({n}) = {result_opt}")
```

#### 3. Сравнительный анализ

Файл `comparison.py` содержит комплексный сравнительный анализ всех реализованных алгоритмов:

- Сравнение времени выполнения различных методов вычисления чисел Фибоначчи
- Сравнение базового и оптимизированного методов решения задачи о рюкзаке
- Анализ производительности алгоритмов размена монет
- Тестирование LIS на различных размерах входных данных
- Измерение использования памяти различными методами

#### 4. Модульное тестирование

В файле `test_dp.py` реализованы комплексные тесты для всех алгоритмов:

class TestFibonacci(unittest.TestCase):
    """Тесты для чисел Фибоначчи"""
    
    def test_fibonacci_base_cases(self):
        """Тест базовых случаев"""
        self.assertEqual(fibonacci_naive(0), 0)
        self.assertEqual(fibonacci_naive(1), 1)
        # ... другие тесты
```

#### 5. Документация

В файле `README.md` представлена полная документация по проекту:
- Теоретическое обоснование методов ДП
- Описание реализованных алгоритмов
- Инструкции по использованию

### Результаты выполнения

#### Пример вывода программы:

```
Лабораторная работа 9: Динамическое программирование
============================================================

1. Числа Фибоначчи
----------------------------------------
Вычисление F(10):
  Наивный рекурсивный: F(10) = 55
  С мемоизацией: F(10) = 55
  Табличный метод: F(10) = 55
  Оптимизированный: F(10) = 55
  Все методы дают одинаковый результат

2. Задача о рюкзаке 0-1
----------------------------------------
Предметы:
  Предмет 1: вес=2, стоимость=3
  Предмет 2: вес=3, стоимость=4
  Предмет 3: вес=4, стоимость=5
  Предмет 4: вес=5, стоимость=6

Вместимость рюкзака: 5
  Максимальная стоимость (базовый ДП): 7
  Максимальная стоимость (оптимизированный ДП): 7
  Оба метода дают одинаковый результат
```

#### Результаты сравнения производительности:

```
Сравнение методов вычисления чисел Фибоначчи
============================================================
n         Наивный (мс)     Мемоизация (мс)   Таблица (мс)     Оптимизир. (мс)   
----------------------------------------------------------------------
5         0.0121           0.0012            0.0008           0.0005           
10        0.1254           0.0015            0.0010           0.0006           
20        15.2341          0.0021            0.0015           0.0008           
30        N/A              0.0028            0.0020           0.0010           
40        N/A              0.0035            0.0025           0.0012           
```

### Ключевые фрагменты кода

#### Числа Фибоначчи с мемоизацией:

def fibonacci_memoization(n, memo=None):
    """
    Вычисление чисел Фибоначчи с мемоизацией (нисходящее ДП).
    Сложность: O(n) - линейная
    Память: O(n) - для хранения мемоизированных значений
    """
    if memo is None:
        memo = {}
    
    if n in memo:
        return memo[n]
    
    if n <= 1:
        result = n
    else:
        result = fibonacci_memoization(n-1, memo) + fibonacci_memoization(n-2, memo)
    
    memo[n] = result
    return result
```

#### Задача о рюкзаке 0-1:

def knapsack_01_optimized(weights, values, capacity):
    """
    Задача о рюкзаке 0-1 с оптимизацией памяти.
    Сложность: O(n * capacity)
    Память: O(capacity) - только один ряд таблицы
    """
    n = len(weights)
    
    # Используем только два ряда вместо всей таблицы
    dp_prev = [0] * (capacity + 1)
    dp_curr = [0] * (capacity + 1)
    
    for i in range(1, n + 1):
        for w in range(capacity + 1):
            if weights[i-1] <= w:
                dp_curr[w] = max(dp_prev[w],
                                dp_prev[w - weights[i-1]] + values[i-1])
            else:
                dp_curr[w] = dp_prev[w]
        
        # Обновляем ряды для следующей итерации
        dp_prev, dp_curr = dp_curr, dp_prev
    
    return dp_prev[capacity]
```

---

## Выводы

1. **Эффективность ДП для задач с перекрывающимися подзадачами** — динамическое программирование демонстрирует высокую эффективность при решении задач, где подзадачи перекрываются и требуют многократного вычисления.

2. **Сравнение подходов** — нисходящий подход (мемоизация) и восходящий (табличный) дают одинаковые результаты, но отличаются по:
   - Временной сложности: оба подхода имеют линейную сложность O(n) для чисел Фибоначчи
   - Пространственной сложности: мемоизация требует O(n) памяти, табличный метод — O(n), оптимизированный — O(1)

3. **Важность оптимизации памяти** — для больших задач оптимизация использования памяти критически важна. Например, в задаче о рюкзаке удалось сократить использование памяти с O(n×capacity) до O(capacity).

4. **Восстановление решения** — восстановление оптимального решения требует дополнительной памяти (например, таблицы направлений в LCS), но предоставляет полное решение задачи, а не только оптимальное значение.

5. **Влияние структуры данных** — правильный выбор структуры данных (словарь для мемоизации, массивы для табличного метода) существенно влияет на производительность алгоритмов.

6. **Применимость к различным задачам** — изученные алгоритмы демонстрируют универсальность метода динамического программирования для решения разнообразных задач: от числовых последовательностей до строковых операций и комбинаторной оптимизации.

---

## Ответы на контрольные вопросы

### 1. Какие два основных свойства задачи указывают на то, что для её решения можно применить динамическое программирование?

**Оптимальная подструктура** — оптимальное решение задачи можно построить из оптимальных решений её подзадач. Например: лучший выбор предметов для ёмкости W включает лучший выбор для меньшей ёмкости W − weight[i].

**Перекрывающиеся подзадачи** — при рекурсивном разбиении одна и та же подзадача возникает многократно. Например: в рекурсивном вычислении Фибоначчи значения F(n−1) и F(n−2) используются десятки раз.

### 2. Разница между top-down и bottom-up подходами?

**Top-down (нисходящий, с мемоизацией):**
- Рекурсивный подход
- Вычисляет только нужные подзадачи
- Использует кэширование (мемоизацию) для хранения результатов
- Более интуитивный, но может иметь накладные расходы на рекурсию

**Bottom-up (восходящий, табличный):**
- Итеративный подход
- Заполняет таблицу от простейших подзадач к сложным
- Всегда вычисляет все подзадачи
- Обычно быстрее и не требует рекурсии

### 3. Как задача о рюкзаке 0-1 демонстрирует оптимальную подструктуру?

Оптимальное решение задачи для некоторой ёмкости строится из оптимальных решений подзадач для меньших ёмкостей. Для каждого предмета есть два варианта:
- Либо предмет не берётся, и решение совпадает с оптимальным для той же ёмкости без этого предмета
- Либо предмет берётся, и решение складывается из стоимости этого предмета и оптимального решения для оставшейся вместимости

Таким образом, большая задача раскладывается на несколько меньших оптимальных подзадач.

### 4. Как строится таблица для LCS?

Таблица для LCS строится как матрица размера (n+1)×(m+1), где n и m — длины строк:
1. Инициализация нулевых строк и столбцов нулями
2. Для каждой ячейки (i,j):
   - Если символы совпадают: dp[i][j] = dp[i-1][j-1] + 1
   - Если символы не совпадают: dp[i][j] = max(dp[i-1][j], dp[i][j-1])
3. Последняя ячейка dp[n][m] содержит длину LCS
4. Для восстановления последовательности используется дополнительная таблица направлений

### 5. Как динамическое программирование уменьшает сложность вычисления Фибоначчи?

Без ДП наивный рекурсивный алгоритм имеет экспоненциальную сложность O(2ⁿ) из-за многократного перевычисления одних и тех же значений. ДП решает эту проблему двумя способами:

**Мемоизация:** сохраняет вычисленные значения в словаре для повторного использования:
- Сложность: O(n)
- Память: O(n)

**Табличный метод:** вычисляет значения последовательно снизу вверх:
- Сложность: O(n)
- Память: O(n) (можно оптимизировать до O(1))

Это устраняет экспоненциальное дублирование вычислений и снижает сложность до линейной.

---

## Приложения

### Файлы проекта:
1. `dynamic_programming.py` — основные алгоритмы ДП
2. `main.py` — демонстрационная программа
3. `comparison.py` — сравнительный анализ
4. `test_dp.py` — модульные тесты
5. `README.md` — документация
6. `Отчет.md` — данный отчет