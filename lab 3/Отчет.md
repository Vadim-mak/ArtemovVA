# Отчет по лабораторной работе №3  
**Тема:** Рекурсия  
**Дата:** 2025-10-16  
**Семестр:** 3 курс, 5 семестр  
**Группа:** ПИЖ-б-о-23-2(2)  
**Дисциплина:** Анализ сложности алгоритмов  
**Студент:** Артемов Вадим Сергеевич  

---

## Цель работы
Изучение методов рекурсивного решения задач, включая факториал, числа Фибоначчи, бинарный поиск, Ханойские башни, а также использование мемоизации для оптимизации рекурсивных алгоритмов.

## Теоретическая часть
Рекурсия — это метод программирования, при котором функция вызывает сама себя. Рекурсивные алгоритмы удобно использовать для решения задач с повторяющейся структурой. Однако наивная рекурсия может быть медленной и потреблять много памяти из-за глубокого стека вызовов. Мемоизация позволяет хранить промежуточные результаты и значительно ускоряет вычисления.

Классические примеры рекурсивных задач:
- Факториал числа
- Числа Фибоначчи
- Бинарный поиск в отсортированном массиве
- Задача Ханойских башен
- Обход файловой системы

## Практическая часть
### Выполненные задачи
1. Реализован рекурсивный расчет факториала  
2. Реализован наивный и мемоизированный расчет чисел Фибоначчи  
3. Реализован рекурсивный бинарный поиск и алгоритм Ханойских башен  
4. Проведено сравнение производительности наивной и мемоизированной рекурсии  

### Ключевые фрагменты кода
#### Факториал (файл `recursion.py`)
```python
def factorial(n):
    if n <= 1:
        return 1
    return n * factorial(n - 1)
Наивный Фибоначчи (файл recursion.py)
python
def fib_naive(n):
    if n <= 1:
        return n
    return fib_naive(n - 1) + fib_naive(n - 2)
Мемоизированный Фибоначчи (файл memoization.py)
python
@lru_cache(maxsize=None)
def fib_memo(n):
    if n <= 1:
        return n
    return fib_memo(n - 1) + fib_memo(n - 2)
Быстрое возведение в степень (файл recursion.py)
python
def fast_pow(a, n):
    if n == 0:
        return 1
    if n % 2 == 0:
        half = fast_pow(a, n // 2)
        return half * half
    else:
        return a * fast_pow(a, n - 1)
Бинарный поиск (файл recursion_tasks.py)
python
def binary_search_recursive(arr, target, left=0, right=None):
    if right is None:
        right = len(arr) - 1
    if left > right:
        return -1
    mid = (left + right) // 2
    if arr[mid] == target:
        return mid
    elif arr[mid] > target:
        return binary_search_recursive(arr, target, left, mid - 1)
    else:
        return binary_search_recursive(arr, target, mid + 1, right)
Ханойские башни (файл recursion_tasks.py)
python
def hanoi_moves(n, source='A', target='C', aux='B', moves=None):
    if moves is None:
        moves = []
    if n == 0:
        return moves
    hanoi_moves(n - 1, source, aux, target, moves)
    moves.append((source, target))
    hanoi_moves(n - 1, aux, target, source, moves)
    return moves
Результаты выполнения
Пример работы программы
Бинарный поиск:

text
binary_search_recursive(arr, 7) -> 7
Ханойские башни (3 диска):

text
Hanoi moves for n=3 (count): 7
1. A -> C
2. A -> B
3. C -> B
4. A -> C
5. B -> A
6. B -> C
7. A -> C
Сравнение времени выполнения (n=30):

text
n=30: naive time ≈ 403.34 ms (1 run)
n=30: memo  time ≈ 0.03 ms (avg 3 runs)
Примечание: время примерное, зависит от системы.

Выводы:
Рекурсия удобна для решения задач с повторяющейся структурой, но может быть ресурсоёмкой.

Мемоизация значительно ускоряет вычисления, особенно для экспоненциальных рекурсий, таких как числа Фибоначчи.

Рекурсивные алгоритмы позволяют наглядно решать задачи бинарного поиска, Ханойских башен и обхода файловой системы.

Глубина рекурсии и стек вызовов требуют осторожности при работе с большими данными.

Ответы на контрольные вопросы
Что такое базовый случай и рекурсивный шаг? Почему отсутствие базового случая приводит к ошибке?
Базовый случай — условие, при котором рекурсия завершается. Рекурсивный шаг — вызов функции с изменёнными аргументами. Отсутствие базового случая приводит к бесконечной рекурсии и переполнению стека.

Как работает мемоизация? Как она меняет сложность вычисления чисел Фибоначчи?
Мемоизация сохраняет результаты вычислений в кэше. Для Фибоначчи она снижает сложность с O(2^n) до O(n).

В чём проблема глубокой рекурсии?
Глубокая рекурсия может вызвать переполнение стека (stack overflow), так как каждый вызов сохраняет в стеке локальные переменные и адрес возврата.

Опишите алгоритм решения Ханойских башен для 3 дисков.

Переместить 2 верхних диска с A на B через C.

Переместить 3-й диск с A на C.

Переместить 2 диска с B на C через A.

Сравните рекурсивный и итеративный подходы.
Рекурсия:

Плюсы: лаконичность, наглядность.

Минусы: риск переполнения стека, больше накладных расходов.
Итерация:

Плюсы: экономия памяти, часто быстрее.

Минусы: код может быть менее читаемым для рекурсивных по своей природе задач.