import time

def factorial(n):
    """
    Рекурсивный факториал.
    Вход: n >= 0 (int)
    Сложность времени: O(n)
    Глубина рекурсии: O(n)
    """
    # базовый случай
    if n <= 1:          # O(1)
        return 1        # O(1)
    # рекурсивный шаг
    return n * factorial(n - 1)  # вызывает факториал(n-1) -> O(n) уровней

def fib_naive(n):
    """
    Наивная рекурсивная версия вычисления n-го Фибоначчи.
    Сложность времени: O(2^n) (экспоненциальная)
    Глубина рекурсии: O(n)
    """
    if n <= 1:          # O(1)
        return n        # O(1)
    return fib_naive(n - 1) + fib_naive(n - 2)  # два рекурсивных вызова

def fast_pow(a, n):
    """
    Быстрое возведение в степень (возведение a^n) рекурсивно.
    Использует разложение по степеням 2.
    Сложность времени: O(log n)
    Глубина рекурсии: O(log n)
    """
    if n == 0:          # O(1)
        return 1        # O(1)
    if n % 2 == 0:      # O(1)
        half = fast_pow(a, n // 2)  # вызов на n/2 -> лог глубина
        return half * half          # O(1)
    else:
        return a * fast_pow(a, n - 1)  # уменьшение на 1

# Базовые проверки (раскомментировать для локального запуска)
if __name__ == "__main__":
    print("factorial(5) =", factorial(5))     # 120
    print("fib_naive(10) =", fib_naive(10))   # 55
    print("fast_pow(2, 10) =", fast_pow(2, 10))  # 1024