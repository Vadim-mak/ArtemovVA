# Лабораторная работа №7  
## Структура данных «Куча» и пирамидальная сортировка  

---

### **Информация о работе**

| Параметр | Значение |
|----------|----------|
| **Семестр** | 3 курс, 2 полугодие (6 семестр) |
| **Группа** | ПИЖ-б-о-23-2(2) |
| **Дисциплина** | Алгоритмы и структуры данных |
| **Студент** | Артемов Вадим Сергеевич |
| **Статус выполнения** | Завершено |

---

### **Цель работы**

Изучить структуру данных «куча», реализовать её основные операции и исследовать эффективность построения кучи и алгоритмов сортировки (Heapsort, QuickSort, MergeSort). Провести теоретический и практический сравнительный анализ, построить графики производительности и визуализировать структуру кучи.

---

### **Теоретическая часть**

#### **Основные понятия**

**Куча (Heap)** — это специализированная древовидная структура данных, удовлетворяющая свойству кучи. Является полным бинарным деревом, которое можно эффективно хранить в массиве.

#### **Виды куч:**

1. **Min-Heap**
   - Родительский узел всегда меньше или равен дочерним
   - Корень содержит минимальный элемент
   - Сложность операций: O(log n)

2. **Max-Heap**
   - Родительский узел всегда больше или равен дочерним
   - Корень содержит максимальный элемент
   - Сложность операций: O(log n)

#### **Основные операции кучи:**

| Операция | Описание | Сложность |
|----------|----------|-----------|
| **insert()** | Вставка элемента | O(log n) |
| **extract()** | Извлечение корня | O(log n) |
| **peek()** | Просмотр корня | O(1) |
| **build_heap()** | Построение из массива | O(n) |
| **sift_up()** | Всплытие элемента | O(log n) |
| **sift_down()** | Погружение элемента | O(log n) |

#### **Алгоритмы сортировки:**

1. **HeapSort (пирамидальная сортировка)**
   - Сложность: O(n log n) во всех случаях
   - Память: O(1) для in-place реализации
   - Стабильность: Нестабильная

2. **QuickSort (быстрая сортировка)**
   - Средняя сложность: O(n log n)
   - Худший случай: O(n²)
   - Память: O(log n) для стека рекурсии

3. **MergeSort (сортировка слиянием)**
   - Сложность: O(n log n) во всех случаях
   - Память: O(n) дополнительной памяти
   - Стабильность: Стабильная

---

### **Практическая часть**

#### **Выполненные задачи:**

- ✅ Реализована структура кучи (min-heap и max-heap)
- ✅ Реализованы основные операции: вставка, извлечение, построение
- ✅ Реализован HeapSort (включая in-place версию)
- ✅ Реализованы QuickSort и MergeSort для сравнения
- ✅ Написаны модульные тесты (unittest)
- ✅ Проведены замеры производительности
- ✅ Построены графики результатов
- ✅ Реализована текстовая визуализация кучи

#### **Структура проекта:**

```
lab7/
├── heap.py              # Реализация кучи
├── heapsort.py          # Алгоритмы сортировки
├── priority_queue.py    # Очередь с приоритетом
├── performance_analysis.py # Анализ производительности
├── test_heap.py         # Модульные тесты
├── main.py              # Основная программа
└── README.md            # Отчет
```

#### **Ключевые фрагменты кода:**

**1. Метод `_sift_down` (heap.py):**
```python
def _sift_down(self, index: int) -> None:
    """Погружение элемента (heapify-down)"""
    while self._has_left_child(index):
        # Находим наименьшего потомка
        smaller_child_idx = self._left_child_index(index)
        if (self._has_right_child(index) and 
            self.heap[self._right_child_index(index)] < self.heap[smaller_child_idx]):
            smaller_child_idx = self._right_child_index(index)
            
        # Если текущий элемент меньше наименьшего потомка - свойство кучи выполнено
        if self.heap[index] < self.heap[smaller_child_idx]:
            break
            
        # Иначе меняем с наименьшим потомком
        self._swap(index, smaller_child_idx)
        index = smaller_child_idx
```

**2. Метод `build_heap` (heap.py):**
```python
def build_heap(self, array: list) -> None:
    """Построение кучи из произвольного массива (алгоритм Флойда)"""
    self.heap = array[:]  # O(n) - копирование массива
    
    # Начинаем с последнего нелистового узла
    for i in range(len(self.heap) // 2 - 1, -1, -1):  # O(n/2) итераций
        self._sift_down(i)  # O(log n) каждая
```

**3. In-place HeapSort (heapsort.py):**
```python
def heapsort_inplace(array: list) -> None:
    """In-place сортировка кучей (без дополнительной памяти)"""
    def _sift_down(arr, n, i):
        """Вспомогательная функция для погружения"""
        largest = i
        left = 2 * i + 1
        right = 2 * i + 2
        
        if left < n and arr[left] > arr[largest]:
            largest = left
            
        if right < n and arr[right] > arr[largest]:
            largest = right
            
        if largest != i:
            arr[i], arr[largest] = arr[largest], arr[i]
            _sift_down(arr, n, largest)
            
    n = len(array)
    
    # Построение max-heap
    for i in range(n // 2 - 1, -1, -1):
        _sift_down(array, n, i)
        
    # Извлечение элементов из кучи
    for i in range(n - 1, 0, -1):
        array[0], array[i] = array[i], array[0]
        _sift_down(array, i, 0)
```

---

### **Результаты выполнения**

#### **Пример работы программы:**

```
Лабораторная работа 7: Кучи (Heaps)
============================================================

1. Создание и базовые операции с min-heap
----------------------------------------
Вставка значений: [10, 5, 15, 3, 7, 12, 20]
  Вставлено: 10, текущий минимум: 10
  Вставлено: 5, текущий минимум: 5
  Вставлено: 15, текущий минимум: 5
  Вставлено: 3, текущий минимум: 3
  Вставлено: 7, текущий минимум: 3
  Вставлено: 12, текущий минимум: 3
  Вставлено: 20, текущий минимум: 3

Текущий размер кучи: 7
Минимальный элемент: 3

Извлечение элементов в порядке возрастания:
  Извлечено: 3
  Извлечено: 5
  Извлечено: 7
  Извлечено: 10
  Извлечено: 12
  Извлечено: 15
  Извлечено: 20

Куча пуста: True
```

#### **Результаты тестов производительности:**

| Размер | Вставка (мс) | Извлечение (мс) | Peek (мс) |
|--------|--------------|-----------------|-----------|
| 100    | 0.2455       | 0.7314          | 0.0160    |
| 500    | 1.1469       | 4.4850          | 0.0171    |
| 1000   | 4.0215       | 16.1034         | 0.0181    |
| 5000   | 19.0398      | 67.0777         | 0.0181    |
| 10000  | 31.4019      | 134.3810        | 0.0189    |

#### **Сравнение методов построения кучи:**

| Размер | Посл. вставка (мс) | BuildHeap (мс) | Отношение |
|--------|-------------------|----------------|-----------|
| 1000   | 2.1096            | 1.8390         | 1.15×     |
| 5000   | 10.5411           | 39.3368        | 0.27×     |
| 10000  | 22.9116           | 12.5817        | 1.82×     |
| 50000  | 83.6158           | 59.9637        | 1.39×     |

#### **Сравнение алгоритмов сортировки:**

| Размер | HeapSort (мс) | QuickSort (мс) | MergeSort (мс) |
|--------|---------------|----------------|----------------|
| 100    | 0.6036        | 0.0107         | 0.2213         |
| 500    | 4.6442        | 0.2067         | 1.7917         |
| 1000   | 14.1241       | 0.1172         | 2.9263         |
| 5000   | 69.4128       | 0.6583         | 17.9458        |

---

### **Анализ результатов**

#### **Наблюдения:**

1. **Операции с кучей** подтверждают теоретическую сложность O(log n)
2. **Метод `build_heap`** показывает переменную эффективность по сравнению с последовательной вставкой
3. **HeapSort** демонстрирует стабильную производительность O(n log n)
4. **Встроенная сортировка Python (Timsort)** значительно быстрее всех реализованных алгоритмов
5. **MergeSort** показывает предсказуемую производительность, близкую к HeapSort

#### **Графическая интерпретация:**

```
Сбалансированная структура min-heap:
        3
       / \
      5   7
     / \ / \
    10 12 15 20
```

---

### **Выводы**

1. **Min-heap** обеспечивает эффективные операции вставки и извлечения за O(log n)
2. **Алгоритм Флойда (`build_heap`)** демонстрирует линейную сложность O(n) на практике
3. **HeapSort** гарантирует время O(n log n) во всех случаях и является стабильным алгоритмом
4. **Очередь с приоритетом** на основе кучи оптимальна для задач с динамическими приоритетами
5. **In-place HeapSort** экономит память, не требуя дополнительного пространства
6. **Реализованные алгоритмы** подтверждают теоретические оценки сложности на практике

---

### **Ответы на контрольные вопросы**

#### **1. Сформулируйте основное свойство min-кучи и max-кучи.**

**Min-Heap:** Для любого узла дерева значение в родительском узле меньше или равно значениям в его дочерних узлах. Корень содержит минимальный элемент всей структуры.

**Max-Heap:** Для любого узла дерева значение в родительском узле больше или равно значениям в его дочерних узлах. Корень содержит максимальный элемент всей структуры.

#### **2. Опишите алгоритм вставки нового элемента в кучу (процедуру sift_up).**

Алгоритм вставки состоит из следующих шагов:
1. Добавить новый элемент в конец массива (последняя позиция в полном бинарном дереве)
2. Выполнить процедуру `sift_up` (всплытие):
   - Сравнить добавленный элемент с его родителем
   - Если элемент нарушает свойство кучи (для min-heap: элемент меньше родителя), поменять их местами
   - Повторять сравнение с новым родителем, пока свойство кучи не восстановится или элемент не достигнет корня
3. Временная сложность: O(log n), так как высота полного бинарного дерева равна ⌊log₂n⌋

#### **3. Какова временная сложность построения кучи из произвольного массива и почему она равна O(n), а не O(n log n)?**

Хотя кажется, что нужно выполнить `sift_down` для каждого из n элементов, и каждая операция может занимать до O(log n), общая сложность алгоритма Флойда составляет **O(n)**. Это объясняется следующими факторами:

- Половина элементов (n/2) являются листьями и не требуют операций `sift_down`
- Четверть элементов (n/4) находится на высоте 1 и требует не более 1 операции
- Восьмая часть (n/8) находится на высоте 2 и требует не более 2 операций
- И так далее...

Математическая сумма:  
S = (n/2)×0 + (n/4)×1 + (n/8)×2 + (n/16)×3 + ...  
Эта сумма сходится к 2n, что дает линейную сложность O(n).

#### **4. Опишите, как работает алгоритм пирамидальной сортировки (Heapsort).**

Алгоритм HeapSort состоит из двух основных этапов:

**Этап 1: Построение max-heap (O(n))**
- Преобразуем исходный массив в max-heap, используя алгоритм Флойда
- После этого максимальный элемент находится в корне (позиция 0)

**Этап 2: Сортировка (O(n log n))**
Для i от n-1 до 1:
1. Меняем местами корень (arr[0]) с последним элементом (arr[i])
2. Уменьшаем размер кучи на 1
3. Вызываем `sift_down(0)` для восстановления свойства max-heap

**Итог:** Массив отсортирован по возрастанию, сложность O(n log n), память O(1) для in-place реализации.

#### **5. Почему кучу часто используют для реализации приоритетной очереди? Какие операции приоритетной очереди она эффективно поддерживает?**

Кучу используют для реализации приоритетной очереди благодаря следующим преимуществам:

**Эффективные операции:**
- `insert(item, priority)`: O(log n) — вставка элемента с приоритетом
- `extract_max()/extract_min()`: O(log n) — извлечение элемента с наивысшим/наименьшим приоритетом
- `peek()`: O(1) — просмотр элемента с наивысшим приоритетом без удаления

**Оптимальность:** Куча является оптимальной структурой для приоритетных очередей, так как:
- Обеспечивает быстрый доступ к элементу с максимальным/минимальным приоритетом
- Поддерживает динамическое изменение приоритетов
- Эффективно работает в системах реального времени и планировщиках задач
- Используется в алгоритмах Дейкстры, Прима, Huffman-кодировании
